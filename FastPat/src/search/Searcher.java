/**
 * Copyright 2014 Mohammed Elseidy, Ehab Abdelhamid

This file is part of Grami.

Grami is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

Grami is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Grami.  If not, see <http://www.gnu.org/licenses/>.
 */

package search;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;

import VF2check.CheckIso;
import dataStructures.Canonizable;
import dataStructures.CompleteQueryPattern;
import dataStructures.DFSCode;
import dataStructures.DFScodeSerializer;
import dataStructures.Edge;
import dataStructures.Frequency;
import dataStructures.Frequented;
import dataStructures.GSpanEdge;
import dataStructures.Graph;
import dataStructures.HPListGraph;
import dataStructures.gEdgeComparator;
import dataStructures.myNode;
import joinAlgorithm.JoinMNI;
import topKresults.MaxHeap;
import topKresults.MinHeap;
import utilities.MyPair;
import utilities.Settings;
import utilities.StopWatch;

public class Searcher<NodeType, EdgeType> {

	private Graph kGraph;//knowledge graph
	public ArrayList<HashMap<SearchLatticeNode<NodeType, EdgeType>, Frequency>> result;
	private HashMap<String, Integer> patternEdgeMap;//meta index of KG
	private HashMap<String, Integer> corePatternEdgeMap;
	private DFSCode<NodeType, EdgeType> corePattern;//read from file
	private DFSCode<NodeType, EdgeType> query;//generated by extension
	public static Hashtable<Integer, Vector<Integer>> neighborLabels;
	public static Hashtable<Integer, Vector<Integer>> revNeighborLabels;
	Map<GSpanEdge<NodeType, EdgeType>, DFSCode<NodeType, EdgeType>> initials;

	private ArrayList<Integer> sortedFrequentLabels;
	private ArrayList<Double> freqEdgeLabels;
	private StopWatch genQueryTime;
	
	public StopWatch getQueryTime(){
		return genQueryTime;
	}
	
	public Searcher(String graphPath, String corePath) throws Exception {
		kGraph = new Graph(1);
		kGraph.loadFromFile_Ehab(graphPath);
		patternEdgeMap = kGraph.getPatternEdgeSet();

		// process core pattern
		CompleteQueryPattern qry = new CompleteQueryPattern(kGraph);
		corePattern = qry.loadFromFile_Core(corePath);
		corePatternEdgeMap = qry.getCorePatternMap();
		JoinMNI j = new JoinMNI(kGraph, patternEdgeMap);
		
		sortedFrequentLabels=kGraph.getSortedFreqLabels();
		freqEdgeLabels = kGraph.getFreqEdgeLabels();
		kGraph.setShortestPaths_1hop();
	}
	
	public void initialize()
	{
		initials= new TreeMap<GSpanEdge<NodeType, EdgeType>, DFSCode<NodeType, EdgeType>>(new gEdgeComparator<NodeType, EdgeType>());
		HashMap<Integer, HashMap<Integer,myNode>> freqNodesByLabel=  kGraph.getFreqNodesByLabel();
		HashSet<Integer> contains= new HashSet<Integer>();
		for (Iterator<  java.util.Map.Entry< Integer, HashMap<Integer,myNode> > >  it= freqNodesByLabel.entrySet().iterator(); it.hasNext();) 
		{
			
			java.util.Map.Entry< Integer, HashMap<Integer,myNode> > ar =  it.next();
			int firstLabel=ar.getKey();
			contains.clear();
			HashMap<Integer,myNode> tmp = ar.getValue();
			for (Iterator<myNode> iterator = tmp.values().iterator(); iterator.hasNext();) 
			{
				myNode node =  iterator.next();
				HashMap<Integer, ArrayList<MyPair<Integer, Double>>> neighbours=node.getReachableWithNodes();
				if(neighbours!=null)
				for (Iterator<Integer>  iter= neighbours.keySet().iterator(); iter.hasNext();) 
				{
					int secondLabel = iter.next();
					int labelA=sortedFrequentLabels.indexOf(firstLabel);
					int labelB=sortedFrequentLabels.indexOf(secondLabel);
					
					//iterate over all neighbor nodes to get edge labels as well
					for (Iterator<MyPair<Integer, Double>>  iter1= neighbours.get(secondLabel).iterator(); iter1.hasNext();)
					{
						MyPair<Integer, Double> mp = iter1.next();
						double edgeLabel = mp.getB();
						if(!freqEdgeLabels.contains(edgeLabel))
							continue;
						
						int secondNodeID = mp.getA();
					
						final GSpanEdge<NodeType, EdgeType> gedge = new GSpanEdge <NodeType, EdgeType>().set(0, 1, labelA, (int)edgeLabel, labelB, 1, firstLabel, secondLabel);
					
						if(!initials.containsKey(gedge))
						{
//							System.out.println(gedge);
						
							final ArrayList<GSpanEdge<NodeType, EdgeType>> parents = new ArrayList<GSpanEdge<NodeType, EdgeType>>(
								2);
							parents.add(gedge);
							parents.add(gedge);
						
							HPListGraph<NodeType, EdgeType> lg = new HPListGraph<NodeType, EdgeType>();
							gedge.addTo(lg);
							DFSCode<NodeType, EdgeType> code = new DFSCode<NodeType,EdgeType>(sortedFrequentLabels,kGraph,null).set(lg, gedge, gedge, parents);
						
							initials.put(gedge, code);
						}
					}
				}
			}
		}
		
		neighborLabels = new Hashtable();
		revNeighborLabels = new Hashtable();
		for (final Iterator<Map.Entry<GSpanEdge<NodeType, EdgeType>, DFSCode<NodeType, EdgeType>>> eit = initials
				.entrySet().iterator(); eit.hasNext();) 
		{
			final DFSCode<NodeType, EdgeType> code = eit.next().getValue();
			
			int labelA;
			int labelB;
			GSpanEdge<NodeType, EdgeType> edge = code.getFirst();
			if (edge.getDirection() == Edge.INCOMING) {
				labelA = edge.getThelabelB();
				labelB = edge.getThelabelA();
			} else {
				labelB = edge.getThelabelB();
				labelA = edge.getThelabelA();
			}
			//add to labels
			Vector temp = neighborLabels.get(labelA);
			if(temp==null)
			{
				temp = new Vector();
				neighborLabels.put(labelA, temp);
			}
			temp.addElement(labelB);
			//add reverse labels
			temp = revNeighborLabels.get(labelB);
			if(temp==null)
			{
				temp = new Vector();
				revNeighborLabels.put(labelB, temp);
			}
			temp.addElement(labelA);
		}
	}

	public ArrayList<HashMap<SearchLatticeNode<NodeType, EdgeType>, Frequency>> search() {
		Algorithm<NodeType, EdgeType> extend = new Algorithm<NodeType, EdgeType>();
		extend.setOneEdgePatterns(patternEdgeMap);
		
		// generate canonical core pattern
		StopWatch qryWatch = new StopWatch();
		qryWatch.start();
		int[][] maxDegreeMatrix = kGraph.getMaxDegreeMatrix();
		ArrayList<Integer> sortedNodeLabels = kGraph.getSortedFreqLabels();
		Extender<NodeType, EdgeType> qryExtender = null;
		if (Settings.HMT) {
			qryExtender = extend.PatExtMeta(corePatternEdgeMap, maxDegreeMatrix, sortedNodeLabels, kGraph);
			initialize();
		} else if (!Settings.HMT) {
			qryExtender = extend.PatExtMeta(corePatternEdgeMap, maxDegreeMatrix, sortedNodeLabels, kGraph);
		}
		CheckIso c = new CheckIso(corePattern);
		ArrayList<SearchLatticeNode<NodeType, EdgeType>> initialList = new ArrayList<SearchLatticeNode<NodeType, EdgeType>>();
		for(Entry<GSpanEdge<NodeType, EdgeType>, DFSCode<NodeType, EdgeType>> entry: initials.entrySet()){
			DFSCode<NodeType, EdgeType> pattern = entry.getValue();
			String pString = DFScodeSerializer.serializePatternToString(pattern);
			if(corePatternEdgeMap.containsKey(pString)){
				initialList.add(pattern);
			}
		}
		while(initialList != null && initialList.size() != 0){
			initialList = getCanonicalCore(initialList, qryExtender);
		}
		qryWatch.stop();
		this.genQueryTime = qryWatch;
		System.out.println("genCore_elapsedTime:" + qryWatch.getElapsedTime() / 1000.0);
		
		// Entrance of FastPat
		EnumerateStrategy<NodeType, EdgeType> rs = new EnumerateStrategy<NodeType, EdgeType>(kGraph, patternEdgeMap);
		result = rs.search(extend, query);
		return result;
	}
	
	// generate the canonical core pattern
	public ArrayList<SearchLatticeNode<NodeType, EdgeType>> getCanonicalCore(ArrayList<SearchLatticeNode<NodeType, EdgeType>> list, 
			Extender<NodeType, EdgeType> qryExtender){
		ArrayList<SearchLatticeNode<NodeType, EdgeType>> retSet = new ArrayList<SearchLatticeNode<NodeType, EdgeType>>();
		Iterator it = list.iterator();
		while (it.hasNext()) {
			SearchLatticeNode<NodeType, EdgeType> pattern = (SearchLatticeNode<NodeType, EdgeType>) it.next();
			if (pattern.getHPlistGraph().getNodeCount() == corePattern.getHPlistGraph().getNodeCount()
					&& pattern.getHPlistGraph().getEdgeCount() == corePattern.getHPlistGraph().getEdgeCount()) {
				boolean iso = CheckIso.checkIso(pattern);
				if(iso){
					this.query = (DFSCode<NodeType, EdgeType>) pattern;
					return null;
//					break;
				}
			}else{
				final Collection<SearchLatticeNode<NodeType, EdgeType>> children = qryExtender.getChildren(pattern);
				for (SearchLatticeNode<NodeType, EdgeType> child : children) {
					final Canonizable can = (Canonizable) child;
					if (!can.isCanonical()) {// if the child pattern is minimum DFSCode
//						System.out.println("Not Canonizable!!!");
						continue;
					}
					retSet.add(child);
				}
			}
			it.remove();
		}
		return retSet;
	}

	public Graph getKGraph() {
		return kGraph;
	}
	
	public DFSCode<NodeType, EdgeType> getCorePattern(){
		return corePattern;
	}

}
